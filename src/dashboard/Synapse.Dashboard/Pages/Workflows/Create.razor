@page "/workflows/new"
@using ServerlessWorkflow.Sdk.Services.IO
@using ServerlessWorkflow.Sdk.Services.Validation
@using Synapse.Integration.Commands.Workflows
@using Synapse.Integration.Models
@using Synapse.Integration.Services
@using Synapse.Dashboard.Components
@using System.Text
@inject ISynapseApi SynapseApi
@inject IWorkflowReader WorkflowReader
@inject IWorkflowValidator WorkflowValidator

<PageTitle>New workflow</PageTitle>
<AppHeader>
    <span class="h5 m-0 p-0">New workflow</span>
</AppHeader>

<div class="h-100 mh-100 d-flex flex-column justify-content-between align-items-start">
    <label class="form-form-label">Definition</label>
    <MonacoEditor
        @ref="editor"
        Id="definition-editor"
        CssClass="w-100"
        ConstructionOptions="MonacoEditorOptionsBuilder"
        OnDidInit="OnMonacoEditorDidInit"
        OnDidChangeModelDecorations="OnMonacoEditorDidChangeModelDecorations"
    />
    @if(validationErrors != null && validationErrors.Any())
    {
        <div class="validation-errors alert alert-danger">
            <ul>
                @foreach (var error in validationErrors)
                {
                    <li>@error.ToString()</li>
                }
            </ul>
        </div>
    }
    <button disabled="@IsCreateDisabled" @onclick="OnCreateWorkflow" type="button" class="btn btn-blockquote btn-dark">Create Workflow</button>
</div>

@code {
    protected IList<string> validationErrors = new List<string>();
    protected MonacoEditor editor;
    protected bool IsCreateDisabled { get; set; } = true;

    async Task OnCreateWorkflow()
    {
        await this.Validate();
        var rawDefinition = await this.editor.GetValue();
        if (string.IsNullOrWhiteSpace(rawDefinition))
        {
            return;
        }
        var command = new V1CreateWorkflowCommandDto();
        try
        {
            using var stream = new MemoryStream(Encoding.UTF8.GetBytes(rawDefinition));
            command.Definition = await this.WorkflowReader.ReadAsync(stream);
            var validationResult = await this.WorkflowValidator.ValidateAsync(command.Definition, false, true);
            if (!validationResult.IsValid)
            {
                validationResult.SchemaValidationErrors.ToList().ForEach(error =>
                {
                    this.validationErrors.Add($"(Schema) ${error.Message}");
                });
                validationResult.DslValidationErrors.ToList().ForEach(error =>
                {
                    this.validationErrors.Add($"(DSL) ${error.ErrorMessage}");
                });
                return;
            }
        }
        catch(Exception ex)
        {
            Console.WriteLine(ex.ToString());
            //todo: warn the user via validationErrors
            return;
        }
        var workflow = await this.SynapseApi.CreateWorkflowAsync(command);
    }

    protected async Task OnMonacoEditorDidInit(MonacoEditorBase editorBase)
    {
        var model = await this.editor.GetModel();
        await model.jsRuntime.InvokeVoidAsync("enableJsonValidation08" , model.Uri);
    }

    protected async Task OnMonacoEditorDidChangeModelDecorations(ModelDecorationsChangedEvent modelDecorationsChangedEvent)
    {
        await this.Validate();
    }

    protected async Task Validate()
    {
        this.validationErrors.Clear();
        this.IsCreateDisabled = false;
        var model = await this.editor.GetModel();
        var owner = await model.GetModeId();
        var markers = await model.jsRuntime.InvokeAsync<IEnumerable<Models.MonacoEditorMarker>>("getModelMarkers" , owner);
        var severeMarkers = markers.Where(marker => marker.Severity >= (int)Models.MonacoEditorMarkerSeverity.Warning);
        var rawDefinition = await this.editor.GetValue();
        if (severeMarkers.Any())
        {
            this.IsCreateDisabled = true;
            severeMarkers.ToList().ForEach(marker =>
            {
                this.validationErrors.Add($"{marker.Message} ");
            });
        }
        else if (String.IsNullOrEmpty(rawDefinition))
        {
            this.validationErrors.Add("The definition cannot be empty");
            this.IsCreateDisabled = true;
        }
    }

    protected StandaloneEditorConstructionOptions MonacoEditorOptionsBuilder(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions {
		    AutomaticLayout = true,
		    Language = "json",
            Minimap = new EditorMinimapOptions { Enabled = false }
	    };
    }

}
