@using Neuroglia.Data.Flux;
@using System.Reactive.Linq;
@namespace Synapse.Dashboard
@typeparam T
@inject IStore Store;
@inject IDispatcher Dispatcher;

<CascadingValue Value="this">
    @Columns@*needed to initialize columns declared in markup*@
    <table class="@TableClass">
        <thead>
            <tr class="@HeaderRowClass">
                <ColumnHeaderCollectionPresenter T="T" />
            </tr>
        </thead>
        <tbody>
            @if(items != null)
            {
                var index = 0;
                @foreach (var item in items)
                {
                    @RowTemplate(new(this, item, index))
                    index++;
                }
            }
        </tbody>
    </table>
</CascadingValue>

@code 
{

    internal List<Column<T>> columns = new();
    private IEnumerable<T>? items;
    private Column<T>? draggedColumn;

    [Parameter]
    public string? TableClass { get; set; } = "table table-stripped table-hover";

    [Parameter]
    public string? HeaderRowClass { get; set; }

    [Parameter]
    public string? HeaderClass { get; set; }

    [Parameter]
    public string? RowClass { get; set; }

    [Parameter]
    public string? CellClass { get; set; }

    [Parameter]
    public RenderFragment Columns { get; set; } = null!;

    [Parameter]
    public bool AutoGenerateColumns { get; set; } = true;

    [Parameter]
    public RenderFragment<ColumnHeaderRenderingContext<T>> DefaultHeaderTemplate { get; set; } = context => __builder =>
    {
        __builder.OpenComponent(0, typeof(ColumnHeader<T>));
        __builder.AddAttribute(0, nameof(ColumnHeader<T>.RenderContext), context);
        __builder.CloseComponent();
    };

    [Parameter]
    public RenderFragment<RowRenderingContext<T>> RowTemplate { get; set; } = context => __builder =>
    {
        __builder.OpenComponent(0, typeof(Row<T>));
        __builder.AddAttribute(0, nameof(Row<T>.RenderContext), context);
        __builder.CloseComponent();
    };

    [Parameter]
    public RenderFragment<CellRenderingContext<T>> DefaultCellTemplate { get; set; } = context => __builder =>
    {
        __builder.OpenComponent(0, typeof(Cell<T>));
        __builder.AddAttribute(0, nameof(Cell<T>.RenderContext), context);
        __builder.CloseComponent();
    };

    [Parameter]
    public IEnumerable<T>? Items { get; set; }

    [Parameter]
    public EventCallback<Column<T>> OnOrderBy { get; set; }

    public void AddColumn(Column<T> column)
    {
        this.columns.Add(column);
        this.StateHasChanged();
    }

    public bool RemoveColumn(Column<T> column)
    {
        var removed = this.columns.Remove(column);
        this.StateHasChanged();
        return removed;
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        if (this.AutoGenerateColumns)
        {
            foreach(var property in typeof(T)
                .GetProperties()
                .Where(p => p.PropertyType.IsPrimitiveType() || p.PropertyType == typeof(string) || p.PropertyType == typeof(DateTimeOffset)))
            {
                this.AddColumn(Column<T>.CreateFor(property));
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
         if(this.Items is IAsyncEnumerable<T> asyncEnumerable)
            this.items = await asyncEnumerable.ToListAsync();
        else
            this.items = this.Items; 
    }

    internal async Task OnClickColumn(Column<T> column)
    {
        if (!column.IsSorteable
            || column.PropertyPath == null)
            return;
        column.ToggleSortMode();
        await this.OnOrderBy.InvokeAsync(column);
    }

    internal void OnStartDragColumn(Column<T> column)
    {
        this.draggedColumn = column;
    }

    internal void OnEndDragColumn(Column<T> column)
    {
        this.draggedColumn = null;
    }

    internal void OnDropColumnOn(Column<T> column)
    {
        if (column == null
            || this.draggedColumn == null)
            return;
        int draggedIndex = this.columns.IndexOf(this.draggedColumn);
        int droppedIndex = this.columns.IndexOf(column);
        this.columns.Remove(this.draggedColumn);
        int insertAt;
        if (draggedIndex < droppedIndex)
            insertAt = droppedIndex++;
        else
            insertAt = droppedIndex;
        if (droppedIndex >= this.columns.Count)
            droppedIndex = this.columns.Count - 1;
        this.columns.Insert(insertAt, this.draggedColumn);
        this.StateHasChanged();
    }

}
