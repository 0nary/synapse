@page "/diagrams"

@using Blazor.Diagrams.Core
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Core.Models.Base
@using QG = QuikGraph
@using GraphShape.Algorithms.Layout
@using ServerlessWorkflow.Sdk
@using ServerlessWorkflow.Sdk.Models
@using Synapse.Dashboard.Models

<div class="diagram-container">
  <CascadingValue Value="Diagram">
    <DiagramCanvas></DiagramCanvas>
  </CascadingValue>
</div>

@code {

    [Parameter]
    public WorkflowDefinition Definition { get; set; } = null!;

    private Diagram Diagram { get; set; } = null!;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        this.BuildDiagram();
    }

    private void BuildDiagram()
    {
        this.Diagram = new Diagram(new DiagramOptions());
        this.Diagram.RegisterModelComponent<WorkflowStartNodeModel, WorkflowStartNode>();
        this.Diagram.RegisterModelComponent<WorkflowStateNodeModel, WorkflowStateNode>();
        this.Diagram.RegisterModelComponent<WorkflowEndNodeModel, WorkflowEndNode>();

        var startNode = this.BuildStartNode();
        this.Diagram.Nodes.Add(startNode);
        var endNode = this.BuildEndNode();
        this.Diagram.Nodes.Add(endNode);
        var state = this.Definition.GetStartState();
        this.BuildStateNodes(state, endNode, startNode);
        this.ComputeNodePositions();
        this.Diagram.SelectionChanged += this.OnNodeSelectionChanged;
    }

    private NodeModel BuildStartNode()
    {
        var node = new WorkflowStartNodeModel();
        this.Diagram.Nodes.Add(node);
        return node;
    }

    private void BuildStateNodes(StateDefinition state, NodeModel endNode, NodeModel? previousNode = null)
    {
        var stateNodeGroup = new GroupModel(Array.Empty<NodeModel>());
        this.Diagram.AddGroup(stateNodeGroup);
        List<NodeModel> childNodes = new();
        NodeModel firstNode, lastNode;
        switch (state)
        {
            case CallbackStateDefinition callbackState:
                childNodes = this.BuildActionNodes(state, ((CallbackStateDefinition)state).Action!);
                firstNode = childNodes.Last();
                lastNode = this.BuildConsumeEventNode(state, ((CallbackStateDefinition)state).Event!);
                childNodes.Add(lastNode);
                this.BuildLinkBetween(firstNode, lastNode);
                break;
            case EventStateDefinition eventState:

                break;
            case ForEachStateDefinition foreachState:

                break;
            case InjectStateDefinition injectState:

                break;
            case OperationStateDefinition operationState:
                var node = previousNode;
                switch (operationState.ActionMode)
                {
                    case ActionExecutionMode.Parallel:
                        var startNode = this.BuildGatewayNode(state, ParallelCompletionType.And);
                        childNodes.Add(startNode);
                        var finalNode = this.BuildGatewayNode(state, ParallelCompletionType.And);
                        childNodes.Add(finalNode);
                        operationState.Actions.ForEach(action => 
                        {
                            var actionNodes = this.BuildActionNodes(state, action);
                            this.BuildLinkBetween(startNode, actionNodes.First());
                            this.BuildLinkBetween(actionNodes.Last(), finalNode);
                            actionNodes.ForEach(n => stateNodeGroup.AddChild(n));
                        });
                        break;
                    case  ActionExecutionMode.Sequential:
                        var index = 0;
                        foreach (var action in operationState.Actions)
                        {
                            var actionNodes = this.BuildActionNodes(state, action);
                            if (index != 0) 
                                this.BuildLinkBetween(node, actionNodes.First());
                            actionNodes.ForEach(n => childNodes.Add(n));
                            node = actionNodes.First();
                            index++;
                        }
                        break;
                    default:
                        throw new Exception($"The specified action execution mode '{operationState.ActionMode}' is not supported");
                }
                break;
            case ParallelStateDefinition parallelState:

                break;
            case SleepStateDefinition sleepState:

                break;
            case SwitchStateDefinition switchState:
                firstNode = this.BuildGatewayNode(state, ParallelCompletionType.Xor);
                childNodes.Add(firstNode);
                switch (switchState.SwitchType) 
                {
                    case SwitchStateType.Data:
                        switchState.DataConditions.ForEach(condition =>
                        {
                            var caseNode = this.BuildDataConditionNode(state, condition.Name!);
                            childNodes.Add(caseNode);
                            this.BuildLinkBetween(firstNode, caseNode);
                            switch (condition.Type)
                            {
                                case ConditionType.End:
                                    this.BuildLinkBetween(caseNode, endNode);
                                    break;
                                case ConditionType.Transition:
                                    var nextStateName = condition.Transition == null ? condition.TransitionToStateName : condition.Transition.NextState;
                                    var nextState = this.Definition.GetState(nextStateName!);
                                    if (nextState == null)
                                        throw new Exception($"Failed to find a state with name '{nextStateName}' in definition '{this.Definition.GetUniqueIdentifier()}");
                                    this.BuildStateNodes(nextState, endNode, caseNode);
                                    break;
                                default:
                                    throw new Exception($"The specified condition type '${condition.Type}' is not supported");
                            }
                        });
                        node = this.BuildDataConditionNode(state, "default");
                        childNodes.Add(node);
                        if (switchState.DefaultCondition.IsEnd
                            || switchState.DefaultCondition.End != null) 
                        {
                            this.BuildLinkBetween(node, endNode);
                        }
                        else if (!string.IsNullOrWhiteSpace(switchState.DefaultCondition.TransitionToStateName)
                            || switchState.DefaultCondition.Transition != null) 
                        {
                            var nextStateName = switchState.DefaultCondition.Transition == null ? switchState.DefaultCondition.TransitionToStateName : switchState.DefaultCondition.Transition.NextState;
                            var nextState = this.Definition.GetState(nextStateName!);
                            if (nextState == null)
                                throw new Exception($"Failed to find a state with name '{nextStateName}' in definition '{this.Definition.GetUniqueIdentifier()}");
                        }
                        this.BuildLinkBetween(firstNode, node);
                        break;
                    case SwitchStateType.Event:

                        break;
                    default:
                        throw new Exception($"The specified switch state type '{switchState.Type}' is not supported");
                }
                break;
            default:
                throw new Exception($"The specified state type '{state.Type}' is not supported");
        }
        childNodes.ForEach(n => stateNodeGroup.AddChild(n));
        lastNode = childNodes.Last();
        if (previousNode != null) 
            this.BuildLinkBetween(previousNode, childNodes.First());
        if (state.IsEnd
            || state.End != null) 
        {
            this.BuildLinkBetween(childNodes.Last(), endNode);
            return;
        }
        if (!string.IsNullOrWhiteSpace(state.TransitionToStateName)
            || state.Transition != null) 
        {
            var nextStateName = state.Transition == null ? state.TransitionToStateName! : state.Transition!.NextState;
            var nextState = this.Definition.GetState(nextStateName);
            if (nextState == null)
                throw new Exception($"Failed to find a state with name '{nextStateName}' in definition '{this.Definition.GetUniqueIdentifier()}'");
            this.BuildStateNodes(nextState, endNode, lastNode);
            return;
        }
    }

    private List<NodeModel> BuildActionNodes(StateDefinition state, ActionDefinition action)
    {
        switch (action.Type)
        {
            case ActionType.Function:
                return new() { this.BuildFunctionNode(state, action.Function!) };
            case ActionType.Subflow:
                return new() { this.BuildSubflowNode(state, action.Subflow!) };
            case ActionType.Trigger:
                var triggerEventNode = this.BuildProduceEventNode(state, action.Event!.ProduceEvent);
                var resultEventNode = this.BuildConsumeEventNode(state, action.Event!.ResultEvent);
                this.BuildLinkBetween(triggerEventNode, resultEventNode);
                return new() { triggerEventNode, resultEventNode };
            default:
                throw new NotSupportedException($"The specified action type '{action.Type}' is not supported");
        }
    }

    private FunctionRefNodeModel BuildFunctionNode(StateDefinition state, FunctionReference functionRef)
    {
        return new(functionRef);
    }

    private SubflowRefNodeModel BuildSubflowNode(StateDefinition state, SubflowReference subflowRef)
    {
        return new(subflowRef);
    }

    private EventNodeModel BuildProduceEventNode(StateDefinition state, string refName)
    {
        return new(EventKind.Produced, refName);
    }

    private EventNodeModel BuildConsumeEventNode(StateDefinition state, string refName)
    {
        return new(EventKind.Consumed, refName);
    }

    private GatewayNodeModel BuildGatewayNode(StateDefinition state, ParallelCompletionType completionType)
    {
        return new(completionType);
    }

    private DataCaseNodeModel BuildDataConditionNode(StateDefinition state, string caseDefinitionName)
    {
        return new(caseDefinitionName);
    }

    private NodeModel BuildEndNode()
    {
        var node = new WorkflowEndNodeModel();
        this.Diagram.Nodes.Add(node);
        return node;
    }

    private void BuildLinkBetween(NodeModel node1, NodeModel node2)
    {
        this.Diagram.Links.Add(new LinkModel(node1.GetPort(PortAlignment.Bottom), node2.GetPort(PortAlignment.Top)) { Locked = true });
    }

    private void ComputeNodePositions()
    {
        var graph = new QG.BidirectionalGraph<NodeModel, QG.Edge<NodeModel>>();
        var nodes = this.Diagram.Nodes.ToList();
        nodes.AddRange(this.Diagram.Groups.SelectMany(g => g.Children));
        var edges = this.Diagram.Links.OfType<LinkModel>()
            .Select(lm =>
            {
                var source = nodes.Single(dn => dn.Id == lm.SourceNode.Id);
                var target = nodes.Single(dn => dn.Id == lm?.TargetNode?.Id);
                return new QG.Edge<NodeModel>(source, target);
            })
            .ToList();
        graph.AddVertexRange(nodes);
        graph.AddEdgeRange(edges);
        var positions = nodes.ToDictionary(nm => nm, dn => new GraphShape.Point(dn.Position.X, dn.Position.Y));
        var sizes = nodes.ToDictionary(nm => nm, dn => new GraphShape.Size(dn.Size?.Width ?? 75, dn.Size?.Height ?? 75));
        var context = new LayoutContext<NodeModel, QG.Edge<NodeModel>, QG.BidirectionalGraph<NodeModel, QG.Edge<NodeModel>>>(graph, positions, sizes, LayoutMode.Simple);
        var algorithmFactory = new StandardLayoutAlgorithmFactory<NodeModel, QG.Edge<NodeModel>, QG.BidirectionalGraph<NodeModel, QG.Edge<NodeModel>>>();
        var algorithm = algorithmFactory.CreateAlgorithm("Tree", context, null);
        algorithm.Compute();
        try
        {
            this.Diagram.SuspendRefresh = true;
            foreach (var vertex in algorithm.VerticesPositions)
            {
                vertex.Key.SetPosition(vertex.Value.X, vertex.Value.Y);
            }
        }
        finally
        {
            this.Diagram.SuspendRefresh = false;
        }
    }

    private void OnNodeSelectionChanged(SelectableModel elem)
    {
        if (!elem.Selected
         || elem is not NodeModel node)
            return;

    }

}
